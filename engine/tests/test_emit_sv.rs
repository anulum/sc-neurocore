use sc_neurocore_engine::ir::builder::ScGraphBuilder;
use sc_neurocore_engine::ir::emit_sv;
use sc_neurocore_engine::ir::graph::*;
use sc_neurocore_engine::ir::verify;

#[test]
fn emit_single_synapse() {
    let mut b = ScGraphBuilder::new("test_synapse");
    let x = b.input("x_in", ScType::Rate);
    let w = b.constant(ScConst::F64(0.5), ScType::Rate);
    let x_bs = b.encode(x, 1024, 0xACE1);
    let w_bs = b.encode(w, 1024, 0xBEEF);
    let syn = b.bitwise_and(x_bs, w_bs);
    let pc = b.popcount(syn);
    b.output("result", pc);
    let g = b.build();

    assert!(verify::verify(&g).is_ok());
    let sv = emit_sv::emit(&g);

    // Structural checks.
    assert!(sv.contains("module test_synapse"));
    assert!(sv.contains("sc_bitstream_encoder"));
    assert!(sv.contains("sc_bitstream_synapse"));
    assert!(sv.contains("SEED_INIT(16'hACE1)"));
    assert!(sv.contains("SEED_INIT(16'hBEEF)"));
    assert!(sv.contains("endmodule"));
}

#[test]
fn emit_dense_layer() {
    let mut b = ScGraphBuilder::new("test_dense");
    let inputs = b.input(
        "x_fp",
        ScType::Vec {
            element: Box::new(ScType::FixedPoint { width: 16, frac: 8 }),
            count: 3,
        },
    );
    let weights = b.input(
        "w_fp",
        ScType::Vec {
            element: Box::new(ScType::FixedPoint { width: 16, frac: 8 }),
            count: 3,
        },
    );
    let leak = b.constant(ScConst::I64(20), ScType::FixedPoint { width: 16, frac: 8 });
    let gain = b.constant(ScConst::I64(256), ScType::FixedPoint { width: 16, frac: 8 });
    let spikes = b.dense_forward(
        inputs,
        weights,
        leak,
        gain,
        DenseParams {
            n_inputs: 3,
            n_neurons: 7,
            stream_length: 1024,
            ..DenseParams::default()
        },
    );
    b.output("spike_out", spikes);
    let g = b.build();

    assert!(verify::verify(&g).is_ok());
    let sv = emit_sv::emit(&g);

    assert!(sv.contains("module test_dense"));
    assert!(sv.contains("sc_dense_layer_core"));
    assert!(sv.contains("N_INPUTS(3)"));
    assert!(sv.contains("N_NEURONS(7)"));
    assert!(sv.contains("endmodule"));
}

#[test]
fn emit_lif_neuron() {
    let mut b = ScGraphBuilder::new("test_lif");
    let current = b.input("I_t", ScType::FixedPoint { width: 16, frac: 8 });
    let leak = b.constant(ScConst::I64(20), ScType::FixedPoint { width: 16, frac: 8 });
    let gain = b.constant(ScConst::I64(256), ScType::FixedPoint { width: 16, frac: 8 });
    let noise = b.constant(ScConst::I64(0), ScType::FixedPoint { width: 16, frac: 8 });
    let lif = b.lif_step(current, leak, gain, noise, LifParams::default());
    b.output("spike", lif);
    let g = b.build();

    assert!(verify::verify(&g).is_ok());
    let sv = emit_sv::emit(&g);

    assert!(sv.contains("module test_lif"));
    assert!(sv.contains("sc_lif_neuron"));
    assert!(sv.contains("V_THRESHOLD(256)"));
    assert!(sv.contains("REFRACTORY_PERIOD(2)"));
    assert!(sv.contains("endmodule"));
}

#[test]
fn emitted_sv_has_timescale() {
    let mut b = ScGraphBuilder::new("ts_check");
    let x = b.input("x", ScType::Bool);
    b.output("y", x);
    let g = b.build();
    let sv = emit_sv::emit(&g);
    assert!(sv.contains("`timescale 1ns / 1ps"));
}

#[test]
fn emitted_sv_has_header_comment() {
    let mut b = ScGraphBuilder::new("hdr_check");
    let x = b.input("x", ScType::Bool);
    b.output("y", x);
    let g = b.build();
    let sv = emit_sv::emit(&g);
    assert!(sv.contains("Auto-generated by SC-NeuroCore IR Compiler"));
    assert!(sv.contains("Source graph: hdr_check"));
}
